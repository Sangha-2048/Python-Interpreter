In this project the Python interpreter is something that
is the last step of executing the program

Before the interpreter, there are other steps like:
lexing, parsing, and compiling

These steps transform the program's source code in structured code object
containing instructions that interpreter can understand.
Interpreter job is to take these code objects and follow those instructions.

Python interpreter is a stack machine, so it manipulates the stack
to add two numbers.

Python Interpreter is a virtual machine, particularly a stack machine:
it manipulates several stacks to perform its operations.

Python interpreter is a bytecode interpreter. I/P is instruction sets
called bytecode.
Python Code -> Lexer, Parser, Complier -> Generates -> Code objects

Each code object contains a set of instructions to be executed i.e bytecode
 + other info that the interpreter needs.


Here, in this project:
instructions is basically the bytecode and what_to_execute is code object

Version 1.1
Add variables to interpreter
Variables req. instruction to store value of a variable: STORE_NAME
also an instruction to fetch the value: LOAD_NAME

Storing the variable mapping in interpreter itself, ignoring namespaces and
scope for now.

Defining environment dictionary to hold the mapping of names and values.
Now the arguments can mean two things:
1. Index for the number over which we need to load
2. Index for the name

So the STORE_NAME instruction basically pops out the value from the stack
and stores it in the dictionary for future use.
Similarly, when you need the variable value, you can call
LOAD_NAME method to get value and pushed into the stack for
another instructions.

Using getattr method to look up methods on the run-time
instead of using IF-ELSE block every time to check for method.

getattr gives you method reference at the run-time
Example:

class M:
    def square(self, x):
        return x * x

m = M()
sq = getattr(m, "square")
print(sq(2)) # Gives 4

Frames in Python
++++++++++++++++

Collection of information + context for the code
Created and destroyed on the fly as python code executes
There is a frame associated with each call of the function
=> Each frame has one code object associated with it,  a code object
may have multiple frames

If a function calls itself recursively, say 10 times
then it will have one frame associated to each call, therefore
10 frames + 1 frame of the module you started from.

In general, there's a frame for each scope in Python program.

Frames live on call stack, completely different stack we have been discussing above
The lines that we see when an exception occurs in the traceback logs, are
from the call stack. Each line correspond to one frame in the call stack.

Call stack: A Data structure used by python interpreter to store the function calls
Each time a function is called, the Python pushes a frame onto the stack
When function finishes its execution -> pops the frame from the stack
Top of the stack always represent currently executing function

Each frame on call stack has its own data stack and block stack.
Blocks are used for certain kind of control flow, particularly looping and
exception handling.

Example:

>>> def bar(y):
...     z = y + 3     # <--- (3) ... and the interpreter is here.
...     return z
...
>>> def foo():
...     a = 1
...     b = 2
...     return a + bar(b) # <--- (2) ... which is returning a call to bar ...
...
>>> foo()             # <--- (1) We're in the middle of a call to foo ...


Call Stack (left)                   Runtime Stacks (right)
------------------------------------------------------------

bar Frame (newest)                  |   Block stack: []
                                    |   Data stack: [2, 3]

foo Frame                           |   Block stack: []
                                    |   Data stack: [1]

main (module) Frame                 |   Block stack: []
(oldest)                            |   Data stack: []

Creating Classes
++++++++++++++++++++

VirtualMachine:
1. Highest level structure.
2. Contains the mapping of instructions to operations. More complex
version of Interpreter

Frame:
1. Every Frame instance has one code object, and manages few other bits of state
particularly global and local namespaces, a reference to the calling frame and
the last bytecode instruction executed.

Function:
1. Used in place of real function in python
2. A function call creates a frame for python interpreter.
3. We will implement Function class to mimic same functionality

Block:
1. Wraps 3 attributes of blocks.
2. Included here so that our project can run real python code

Namespaces in Python
++++++++++++++++++++++

Mapping of names to objects
1. Name is an identifier you use in your code
Ex: x, my_func, Person

2. Object is the actual value in the memory
Ex: function, integer, Class

Types of namespaces
1. Built-in namespaces
Contains all the built-in names like: len, print, import
Always available everywhere

2. Global namespaces
Created when you run a module file
Hold top level functions, variables and classes
x = 10 # global

def myfunc(): # global function
    pass

3. Local namespaces
Created when a function is called
Holds params and variables defined in a method.

Accessing Python real bytecode
++++++++++++++++++++++++++++++++

>>> def cond():
...     x = 3
...     if x < 5:
...         return 'yes'
...     else:
...         return 'no'

For function object 'cond',
cond.__code__ is code object associated and
cond.__code__.co_code is the bytecode

>>> cond.__code__.co_code  # the bytecode as raw bytes
b'd\x01\x00}\x00\x00|\x00\x00d\x02\x00k\x00\x00r\x16\x00d\x03\x00Sd\x04\x00Sd\x00
   \x00S'
>>> list(cond.__code__.co_code)  # the bytecode as numbers
[100, 1, 0, 125, 0, 0, 124, 0, 0, 100, 2, 0, 107, 0, 0, 114, 22, 0, 100, 3, 0, 83,
 100, 4, 0, 83, 100, 0, 0, 83]

dis module of python is a bytecode disassembler. A disassembler takes machine level code
and converts it into human readable format.


>>> dis.dis(cond)
  2           0 LOAD_CONST               1 (3)
              3 STORE_FAST               0 (x)

  3           6 LOAD_FAST                0 (x)
              9 LOAD_CONST               2 (5)
             12 COMPARE_OP               0 (<)
             15 POP_JUMP_IF_FALSE       22

  4          18 LOAD_CONST               3 ('yes')
             21 RETURN_VALUE

  6     >>   22 LOAD_CONST               4 ('no')
             25 RETURN_VALUE
             26 LOAD_CONST               0 (None)
             29 RETURN_VALUE



Consider first instruction:
Here, first column 2 denotes the line number in python source code
Second column is the index into the byte code, telling us that the LOAD_CONST
instruction appears at position 0
Third column is the instruction itself, mapped to its human-readable format
Fourth is the argument to that instruction, and fifth column when present is the hint
about what argument means.

Considering first few bytes of above cond bytecode
[100, 1, 0, 125, 0, 0]
These six bytes represent 2 instructions with their arguments
We can use dis.opname, a mapping from bytes to intelligible string, to find out instructions
100 to 125, maps to:

dis.opname[100] -> 'LOAD_CONST'
dis.opname[125] -> 'STORE_FAST'